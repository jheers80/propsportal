-- Simple Manual SQL Updates for PR Ops Portal (Using user_roles IDs - Safe Version)
-- This version avoids complex ALTER TABLE operations that can fail
-- Date: September 2, 2025

-- =====================================================
-- 0. ENSURE USER_ROLES TABLE EXISTS
-- =====================================================

-- Create user_roles table if it doesn't exist
CREATE TABLE IF NOT EXISTS user_roles (
  id serial PRIMARY KEY,
  name text UNIQUE NOT NULL,
  display_name text NOT NULL,
  description text
);

-- Insert roles if they don't exist
INSERT INTO user_roles (name, display_name, description) VALUES
  ('superadmin', 'Super Admin', 'Full access to all admin features and settings'),
  ('multiunit', 'Multi-Unit Manager', 'Manages multiple business units or locations'),
  ('manager', 'Manager', 'Manages a single location or team'),
  ('staff', 'Staff', 'Standard staff member with limited access'),
  ('quickaccess', 'Quick Access', 'Temporary or quick access user for limited actions')
ON CONFLICT (name) DO NOTHING;

-- =====================================================
-- 1. BACKUP EXISTING DATA (Optional)
-- =====================================================

-- Create backup tables if you want to preserve existing data
-- Uncomment these lines if you want to backup before making changes

-- CREATE TABLE IF NOT EXISTS role_permissions_backup AS SELECT * FROM role_permissions;
-- CREATE TABLE IF NOT EXISTS profiles_backup AS SELECT * FROM profiles;

-- =====================================================
-- 2. RECREATE ROLE_PERMISSIONS TABLE
-- =====================================================

-- Drop and recreate role_permissions table with correct structure
DROP TABLE IF EXISTS role_permissions CASCADE;

CREATE TABLE role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role INTEGER NOT NULL REFERENCES user_roles(id) ON DELETE CASCADE,
  permission_id BIGINT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
  UNIQUE (role, permission_id)
);

-- =====================================================
-- 3. RECREATE PROFILES TABLE (if needed)
-- =====================================================

-- Only recreate if it doesn't exist or if you want to start fresh
-- This is safer than trying to alter existing enum columns

-- Check if profiles table needs recreation
DO $$
DECLARE
  needs_recreation BOOLEAN := FALSE;
BEGIN
  -- Check if profiles.role is still an enum
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'profiles'
    AND column_name = 'role'
    AND data_type = 'USER-DEFINED'
  ) THEN
    needs_recreation := TRUE;

    -- Backup existing data
    CREATE TEMP TABLE profiles_temp AS SELECT * FROM profiles;

    -- Recreate profiles table with INTEGER role
    DROP TABLE profiles CASCADE;

    CREATE TABLE profiles (
      id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      role INTEGER,
      created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
    );

    -- Set default role after table creation
    ALTER TABLE profiles ALTER COLUMN role SET DEFAULT 4; -- Default to 'staff' role (assuming ID 4)

    -- Restore data with role ID mapping
    INSERT INTO profiles (id, role, created_at)
    SELECT
        pt.id,
        CASE
            WHEN pt.role::text = 'superadmin' THEN (SELECT id FROM user_roles WHERE name = 'superadmin')
            WHEN pt.role::text = 'multiunit' THEN (SELECT id FROM user_roles WHERE name = 'multiunit')
            WHEN pt.role::text = 'manager' THEN (SELECT id FROM user_roles WHERE name = 'manager')
            WHEN pt.role::text = 'staff' THEN (SELECT id FROM user_roles WHERE name = 'staff')
            WHEN pt.role::text = 'quickaccess' THEN (SELECT id FROM user_roles WHERE name = 'quickaccess')
            ELSE (SELECT id FROM user_roles WHERE name = 'staff')
        END,
        pt.created_at
    FROM profiles_temp pt;

    -- Add foreign key constraint
    ALTER TABLE profiles ADD CONSTRAINT profiles_role_fkey
      FOREIGN KEY (role) REFERENCES user_roles(id);

    RAISE NOTICE 'Recreated profiles table with INTEGER role column';
  END IF;
END $$;

-- Add full_name column to profiles table if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'profiles' AND column_name = 'full_name'
  ) THEN
    ALTER TABLE profiles ADD COLUMN full_name TEXT;
    RAISE NOTICE 'Added full_name column to profiles table';
  END IF;
END $$;

-- Add email column to profiles table if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'profiles' AND column_name = 'email'
  ) THEN
    ALTER TABLE profiles ADD COLUMN email TEXT;
    RAISE NOTICE 'Added email column to profiles table';
  END IF;
END $$;

-- Update get_my_role function to work with integer role IDs
-- This function bypasses RLS to prevent infinite recursion
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS TEXT AS $$
DECLARE
  user_role_name TEXT;
BEGIN
  -- Query profiles table directly without RLS restrictions
  SELECT ur.name INTO user_role_name
  FROM public.profiles p
  JOIN public.user_roles ur ON p.role = ur.id
  WHERE p.id = auth.uid();

  RETURN COALESCE(user_role_name, 'staff');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 9. UPDATE RLS POLICIES FOR NEW ROLE SYSTEM
-- =====================================================

-- Enable RLS on tables if not already enabled
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;

-- Profiles RLS Policies
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can view all profiles" ON public.profiles;
CREATE POLICY "Admins can view all profiles" ON public.profiles
  FOR SELECT USING (get_my_role() IN ('superadmin', 'manager'));

DROP POLICY IF EXISTS "Admins can update profiles" ON public.profiles;
CREATE POLICY "Admins can update profiles" ON public.profiles
  FOR UPDATE USING (get_my_role() IN ('superadmin', 'manager'));

-- Role Permissions RLS Policies
DROP POLICY IF EXISTS "Authenticated users can view role permissions" ON public.role_permissions;
CREATE POLICY "Authenticated users can view role permissions" ON public.role_permissions
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Superadmins can manage role permissions" ON public.role_permissions;
CREATE POLICY "Superadmins can manage role permissions" ON public.role_permissions
  FOR ALL USING (get_my_role() = 'superadmin');

-- Permissions RLS Policies
DROP POLICY IF EXISTS "Authenticated users can view permissions" ON public.permissions;
CREATE POLICY "Authenticated users can view permissions" ON public.permissions
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Superadmins can manage permissions" ON public.permissions;
CREATE POLICY "Superadmins can manage permissions" ON public.permissions
  FOR ALL USING (get_my_role() = 'superadmin');

-- Locations RLS Policies
DROP POLICY IF EXISTS "Authenticated users can view all locations" ON public.locations;
CREATE POLICY "Authenticated users can view all locations" ON public.locations
  FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS "Admins can manage locations" ON public.locations;
CREATE POLICY "Admins can manage locations" ON public.locations
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM profiles p
      JOIN user_roles ur ON p.role = ur.id
      WHERE p.id = auth.uid() AND ur.name = 'superadmin'
    )
  );

-- User Locations RLS Policies
DROP POLICY IF EXISTS "Users can view their own location assignments" ON public.user_locations;
CREATE POLICY "Users can view their own location assignments" ON public.user_locations
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can manage user location assignments" ON public.user_locations;
CREATE POLICY "Admins can manage user location assignments" ON public.user_locations
  FOR ALL USING (get_my_role() = 'superadmin');

-- Passphrases RLS Policies (if table exists)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'passphrases') THEN
    -- Drop existing policies
    DROP POLICY IF EXISTS "Users can view passphrases for their assigned locations" ON public.passphrases;
    DROP POLICY IF EXISTS "Admins can manage passphrases" ON public.passphrases;

    -- Create new policies
    CREATE POLICY "Users can view passphrases for their assigned locations" ON public.passphrases
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM user_locations ul
          WHERE ul.user_id = auth.uid() AND ul.location_id = passphrases.location_id
        )
      );

    CREATE POLICY "Admins can manage passphrases" ON public.passphrases
      FOR ALL USING (get_my_role() IN ('superadmin', 'manager'));
  END IF;
END $$;

-- Features RLS Policies (if table exists)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'features') THEN
    -- Drop existing policies
    DROP POLICY IF EXISTS superadmin_write ON features;
    DROP POLICY IF EXISTS portal_user_read ON features;

    -- Create new policies
    CREATE POLICY superadmin_write ON features
      FOR ALL
      USING (get_my_role() = 'superadmin')
      WITH CHECK (get_my_role() = 'superadmin');

    CREATE POLICY portal_user_read ON features
      FOR SELECT
      USING (get_my_role() IN (SELECT unnest(features.roles)));
  END IF;
END $$;

-- Audit Trails RLS Policies (if table exists)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'audit_trails') THEN
    -- Drop existing policies
    DROP POLICY IF EXISTS superadmin_audit_access ON audit_trails;

    -- Create new policy
    CREATE POLICY superadmin_audit_access ON audit_trails
      FOR ALL
      USING (get_my_role() = 'superadmin');
  END IF;
END $$;

-- Add full_name column to profiles table if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'profiles' AND column_name = 'full_name'
  ) THEN
    ALTER TABLE profiles ADD COLUMN full_name TEXT;
    RAISE NOTICE 'Added full_name column to profiles table';
  END IF;
END $$;

-- Create audit trails table for admin actions
CREATE TABLE IF NOT EXISTS audit_trails (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  user_email TEXT,
  user_role TEXT,
  action TEXT NOT NULL,
  resource_type TEXT NOT NULL,
  resource_id TEXT,
  details JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable Row Level Security
ALTER TABLE audit_trails ENABLE ROW LEVEL SECURITY;

-- Policy: Only superadmins can view audit trails
DROP POLICY IF EXISTS superadmin_audit_access ON audit_trails;
CREATE POLICY superadmin_audit_access ON audit_trails
  FOR ALL
  USING (get_my_role() = 'superadmin');

-- Indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_audit_trails_user_id ON audit_trails(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_trails_action ON audit_trails(action);
CREATE INDEX IF NOT EXISTS idx_audit_trails_resource_type ON audit_trails(resource_type);
CREATE INDEX IF NOT EXISTS idx_audit_trails_created_at ON audit_trails(created_at DESC);

-- =====================================================
-- 5. UPDATE QUICK LOGIN FUNCTION
-- =====================================================

-- Function: quick_login_start_session(passphrase TEXT, role TEXT)
DROP FUNCTION IF EXISTS public.quick_login_start_session(TEXT, TEXT);
CREATE OR REPLACE FUNCTION public.quick_login_start_session(p_passphrase TEXT, p_role TEXT DEFAULT 'quickaccess')
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_location_id BIGINT;
  v_session_id BIGINT;
BEGIN
  SELECT location_id INTO v_location_id
  FROM public.passphrases
  WHERE passphrase = p_passphrase
  LIMIT 1;

  IF v_location_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid passphrase');
  END IF;

  INSERT INTO public.quick_access_sessions (location_id, passphrase_hash, expires_at, role)
  VALUES (
    v_location_id,
    encode(digest(convert_to(p_passphrase::text, 'UTF8'), 'sha256'), 'hex'),
    now() + interval '1 hour',
    p_role
  )
  RETURNING id INTO v_session_id;

  RETURN jsonb_build_object('success', true, 'location_id', v_location_id, 'session_id', v_session_id);
END;
$$;

-- =====================================================
-- 6. UPDATE PERMISSIONS
-- =====================================================

-- Insert permissions if they don't exist
INSERT INTO permissions (name, description) VALUES
  ('audit.view', 'View audit trails and system logs'),
  ('users.view', 'View user management'),
  ('users.create', 'Create new users'),
  ('users.update', 'Update user information'),
  ('users.delete', 'Delete users'),
  ('features.view', 'View feature management'),
  ('features.create', 'Create new features'),
  ('features.update', 'Update feature settings'),
  ('features.delete', 'Delete features'),
  ('locations.view', 'View location management'),
  ('locations.create', 'Create new locations'),
  ('locations.update', 'Update location information'),
  ('locations.delete', 'Delete locations'),
  ('passphrases.view', 'View passphrase management'),
  ('passphrases.create', 'Generate new passphrases'),
  ('passphrases.update', 'Update passphrase settings'),
  ('passphrases.delete', 'Delete passphrases')
ON CONFLICT (name) DO NOTHING;

-- =====================================================
-- 7. POPULATE ROLE PERMISSIONS
-- =====================================================

-- Clear existing role_permissions
TRUNCATE TABLE role_permissions;

-- Add all permissions to superadmin
INSERT INTO role_permissions (role, permission_id)
SELECT ur.id, p.id
FROM user_roles ur
CROSS JOIN permissions p
WHERE ur.name = 'superadmin';

-- Manager permissions
INSERT INTO role_permissions (role, permission_id)
SELECT ur.id, p.id
FROM user_roles ur
JOIN permissions p ON p.name IN ('users.view', 'locations.view', 'passphrases.view', 'passphrases.create')
WHERE ur.name = 'manager';

-- Multi-unit manager permissions
INSERT INTO role_permissions (role, permission_id)
SELECT ur.id, p.id
FROM user_roles ur
JOIN permissions p ON p.name IN ('users.view', 'locations.view', 'locations.create', 'locations.update', 'passphrases.view', 'passphrases.create')
WHERE ur.name = 'multiunit';

-- Staff permissions
INSERT INTO role_permissions (role, permission_id)
SELECT ur.id, p.id
FROM user_roles ur
JOIN permissions p ON p.name IN ('users.view', 'features.view')
WHERE ur.name = 'staff';

-- Quick access permissions
INSERT INTO role_permissions (role, permission_id)
SELECT ur.id, p.id
FROM user_roles ur
JOIN permissions p ON p.name IN ('features.view')
WHERE ur.name = 'quickaccess';

-- =====================================================
-- 8. UPDATE FEATURES POLICIES
-- =====================================================

-- Update features table RLS policies
DROP POLICY IF EXISTS superadmin_write ON features;
DROP POLICY IF EXISTS portal_user_read ON features;

CREATE POLICY superadmin_write ON features
    FOR ALL
    USING (get_my_role() = 'superadmin')
    WITH CHECK (get_my_role() = 'superadmin');

CREATE POLICY portal_user_read ON features
    FOR SELECT
    USING (get_my_role() IN (SELECT unnest(features.roles)));

-- =====================================================
-- VERIFICATION
-- =====================================================

SELECT
    'User Roles Table' as component,
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_roles')
         THEN '✓ Exists' ELSE '✗ Missing' END as status
UNION ALL
SELECT
    'Audit Trails Table',
    CASE WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'audit_trails')
         THEN '✓ Created' ELSE '✗ Failed' END
UNION ALL
SELECT
    'Permissions Count',
    COUNT(*)::TEXT FROM permissions
UNION ALL
SELECT
    'Role Permissions Count',
    COUNT(*)::TEXT FROM role_permissions
UNION ALL
SELECT
    'Profiles Role Type',
    CASE
        WHEN EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'profiles' AND column_name = 'role' AND data_type = 'integer'
        ) THEN '✓ Using IDs'
        ELSE '⚠ Check Required'
    END;
