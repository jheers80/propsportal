-- Combined migration file from all migrations

-- From: 20250825123600_create_profiles_table.sql
-- Create the profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT DEFAULT 'user',
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create a function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, role)
  VALUES (new.id, 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a trigger to call the function when a new user is created
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- From: 20250825132118_add_roles_and_permissions.sql
-- Create an enum type for user roles
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE user_role AS ENUM (
      'user',
      'staff',
      'manager',
      'multiunit',
      'superadmin'
    );
  END IF;
END
$$;

-- Alter the profiles table to use the new enum type
-- Also, update the default value.
ALTER TABLE public.profiles
  ALTER COLUMN role DROP DEFAULT,
  ALTER COLUMN role TYPE user_role USING role::user_role,
  ALTER COLUMN role SET DEFAULT 'user';

-- Update the handle_new_user function to work with the new enum
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, role)
  VALUES (new.id, 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Create a permissions table
CREATE TABLE IF NOT EXISTS public.permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create a role_permissions table to link roles and permissions
CREATE TABLE IF NOT EXISTS public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role user_role NOT NULL,
  permission_id BIGINT NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
  UNIQUE (role, permission_id)
);

-- Seed permissions
INSERT INTO public.permissions (name, description) VALUES
('users.create', 'Create new users'),
('users.read', 'Read user information'),
('users.update', 'Update user information'),
('users.delete', 'Delete users')
ON CONFLICT (name) DO NOTHING;

-- Seed role_permissions
-- superadmin has all user-related permissions
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'superadmin', id FROM public.permissions WHERE name IN ('users.create', 'users.read', 'users.update', 'users.delete')
ON CONFLICT (role, permission_id) DO NOTHING;

-- manager can read and update users
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'manager', id FROM public.permissions WHERE name IN ('users.read', 'users.update')
ON CONFLICT (role, permission_id) DO NOTHING;

-- staff can read users
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'staff', id FROM public.permissions WHERE name = 'users.read'
ON CONFLICT (role, permission_id) DO NOTHING;

-- From: 20250825140000_create_locations_table.sql
CREATE TABLE IF NOT EXISTS locations (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  store_id varchar(4) NOT NULL,
  store_name text,
  city text,
  state text,
  zip text,
  created_at timestamptz DEFAULT now() NOT NULL
);

ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow authenticated users to read locations" ON public.locations;
CREATE POLICY "Allow authenticated users to read locations"
ON public.locations
FOR SELECT
TO authenticated
USING (true);


-- From: 20250825140500_create_user_locations_table.sql
CREATE TABLE IF NOT EXISTS user_locations (
  user_id uuid NOT NULL REFERENCES auth.users(id),
  location_id bigint NOT NULL REFERENCES locations(id),
  PRIMARY KEY (user_id, location_id)
);

ALTER TABLE public.user_locations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow authenticated users to read user_locations" ON public.user_locations;
CREATE POLICY "Allow authenticated users to read user_locations"
ON public.user_locations
FOR SELECT
TO authenticated
USING (true);

-- From: 20250825171830_create_quick_access_sessions_table.sql
CREATE TABLE IF NOT EXISTS quick_access_sessions (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  location_id BIGINT NOT NULL REFERENCES public.locations(id) ON DELETE CASCADE,
  passphrase_hash TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  role TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE quick_access_sessions ENABLE ROW LEVEL SECURITY;

-- Helper function to get the role of the currently authenticated user
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS user_role AS $$
DECLARE
  user_role_val user_role;
BEGIN
  SELECT role INTO user_role_val FROM public.profiles WHERE id = auth.uid();
  RETURN user_role_val;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP POLICY IF EXISTS "Allow admins to manage quick access sessions" ON quick_access_sessions;

CREATE POLICY "Allow admins to manage quick access sessions"
ON quick_access_sessions
FOR ALL
TO authenticated
USING (
  get_my_role() = 'superadmin'
);
