-- Create an enum type for user roles
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE user_role AS ENUM (
      'user',
      'staff',
      'manager',
      'multiunit',
      'superadmin'
    );
  END IF;
END
$$;

-- Alter the profiles table to use the new enum type
-- Also, update the default value.
ALTER TABLE public.profiles
  ALTER COLUMN role DROP DEFAULT,
  ALTER COLUMN role TYPE user_role USING role::user_role,
  ALTER COLUMN role SET DEFAULT 'user';

-- Update the handle_new_user function to work with the new enum
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, role)
  VALUES (new.id, 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Create a permissions table
CREATE TABLE IF NOT EXISTS public.permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create a role_permissions table to link roles and permissions
CREATE TABLE IF NOT EXISTS public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role user_role NOT NULL,
  permission_id BIGINT NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
  UNIQUE (role, permission_id)
);

-- Seed permissions
INSERT INTO public.permissions (name, description) VALUES
('users.create', 'Create new users'),
('users.read', 'Read user information'),
('users.update', 'Update user information'),
('users.delete', 'Delete users')
ON CONFLICT (name) DO NOTHING;

-- Seed role_permissions
-- superadmin has all user-related permissions
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'superadmin', id FROM public.permissions WHERE name IN ('users.create', 'users.read', 'users.update', 'users.delete')
ON CONFLICT (role, permission_id) DO NOTHING;

-- manager can read and update users
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'manager', id FROM public.permissions WHERE name IN ('users.read', 'users.update')
ON CONFLICT (role, permission_id) DO NOTHING;

-- staff can read users
INSERT INTO public.role_permissions (role, permission_id)
SELECT 'staff', id FROM public.permissions WHERE name = 'users.read'
ON CONFLICT (role, permission_id) DO NOTHING;
